# 管道占位符功能演示

这个示例展示了表达式引擎的管道占位符功能，这是一个强大的语法糖，让数据处理变得更加简洁和直观。

## 功能特性

### 🎯 占位符语法 `#`
- 使用 `#` 作为管道中当前元素的占位符
- 支持复杂的表达式和嵌套运算
- 提供比传统Lambda语法更简洁的写法

### 🔄 管道操作
- `filter(# > 5)` - 过滤操作
- `map(# * 2)` - 映射变换
- 支持链式管道操作

### 🧮 复杂表达式
- 算术运算：`# * 2 + 1`, `(# + 1) * 2`
- 比较运算：`# > 5`, `# >= 3 && # <= 7`
- 模运算：`# % 2 == 0`, `# % 3 == 0`

## 运行示例

```bash
cd example/pipeline_placeholder_demo
go run main.go
```

## 示例输出

```
🔥 管道占位符功能演示
===================

📝 1. 基础占位符用法
-------------------
  ✅ 基础过滤      : [6 7 8 9 10]
     表达式: data | filter(# > 5)
     说明: 获取大于5的数字

  ✅ 基础映射      : [2 4 6 8 10 12 14 16 18 20]
     表达式: data | map(# * 2)
     说明: 每个数字乘以2

🧮 2. 复杂表达式
---------------
  ✅ 模运算       : [3 6 9]
     表达式: data | filter(# % 3 == 0)
     说明: 3的倍数

  ✅ 复杂算术     : [3 5 7 9 11 13 15 17 19 21]
     表达式: data | map(# * 2 + 1)
     说明: 乘以2再加1

⛓️  3. 链式管道操作
------------------
  ✅ 多级过滤     : [4 6 8 10]
     表达式: data | filter(# > 3) | filter(# % 2 == 0)
     说明: 大于3的偶数

  ✅ 复合变换     : [26 50 82]
     表达式: data | filter(# % 2 == 1) | map(# * # + 1) | filter(# > 10)
     说明: 奇数平方加1后大于10
```

## 语法对比

### 传统Lambda语法 vs 占位符语法

```go
// 传统写法（冗长）
"filter(numbers, x => x > 5)"
"map(filter(numbers, x => x % 2 == 0), y => y * 2)"

// 占位符语法（简洁）
"numbers | filter(# > 5)"
"numbers | filter(# % 2 == 0) | map(# * 2)"
```

### 复杂表达式示例

```go
// 业务规则
"users | filter(#.age >= 30 && #.salary > 75000) | map(#.name)"

// 数据分析
"orders | filter(#.status == 'completed') | map(#.amount) | sum()"

// 多级处理
"data | filter(# > 3) | map(# * 2) | filter(# % 4 == 0)"
```

## 性能特性

- **编译优化**: 支持预编译和重用
- **零反射**: 高性能执行
- **内存友好**: 优化的内存使用
- **类型安全**: 完整的类型检查

## 适用场景

1. **数据过滤和转换**
2. **业务规则引擎**
3. **配置驱动的数据处理**
4. **实时数据分析**
5. **API查询和筛选**

管道占位符语法让复杂的数据处理变得简单直观，是函数式编程在Go中的优雅实现。 