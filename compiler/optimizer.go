package compiler

import (
	"github.com/mredencom/expr/vm"
)

// BytecodeOptimizer performs optimizations on generated bytecode
type BytecodeOptimizer struct {
	optimizationLevel int
}

// OptimizationLevel represents the level of optimization to perform
type OptimizationLevel int

const (
	OptimizationNone OptimizationLevel = iota
	OptimizationBasic
	OptimizationAggressive
)

// NewBytecodeOptimizer creates a new bytecode optimizer
func NewBytecodeOptimizer(level OptimizationLevel) *BytecodeOptimizer {
	return &BytecodeOptimizer{
		optimizationLevel: int(level),
	}
}

// OptimizeInstructions applies various optimizations to bytecode instructions
func (bo *BytecodeOptimizer) OptimizeInstructions(instructions []byte) []byte {
	if bo.optimizationLevel == int(OptimizationNone) {
		return instructions
	}

	optimized := instructions

	// Apply basic optimizations
	optimized = bo.mergePushPop(optimized)
	optimized = bo.eliminateNoop(optimized)

	if bo.optimizationLevel >= int(OptimizationAggressive) {
		// Apply aggressive optimizations
		optimized = bo.fuseArithmeticInstructions(optimized)
		optimized = bo.optimizeConstantSequences(optimized)
	}

	return optimized
}

// mergePushPop removes consecutive push/pop operations that cancel out
func (bo *BytecodeOptimizer) mergePushPop(instructions []byte) []byte {
	if len(instructions) < 2 {
		return instructions
	}

	result := make([]byte, 0, len(instructions))
	i := 0

	for i < len(instructions) {
		current := vm.Opcode(instructions[i])

		// Look for OpConstant followed by OpPop pattern
		if current == vm.OpConstant && i+3 < len(instructions) {
			if vm.Opcode(instructions[i+3]) == vm.OpPop {
				// Skip both instructions
				i += 4
				continue
			}
		}

		// Look for duplicate stack operations
		if current == vm.OpDup && i+1 < len(instructions) {
			if vm.Opcode(instructions[i+1]) == vm.OpPop {
				// OpDup followed by OpPop is essentially a no-op
				i += 2
				continue
			}
		}

		// Copy current instruction
		if current == vm.OpConstant && i+2 < len(instructions) {
			// Copy opcode and 2-byte operand
			result = append(result, instructions[i:i+3]...)
			i += 3
		} else {
			result = append(result, instructions[i])
			i++
		}
	}

	return result
}

// eliminateNoop removes no-operation instructions
func (bo *BytecodeOptimizer) eliminateNoop(instructions []byte) []byte {
	result := make([]byte, 0, len(instructions))
	i := 0

	for i < len(instructions) {
		current := vm.Opcode(instructions[i])

		if current == vm.OpNoop {
			i++
			continue
		}

		// Copy instruction
		if current == vm.OpConstant && i+2 < len(instructions) {
			result = append(result, instructions[i:i+3]...)
			i += 3
		} else {
			result = append(result, instructions[i])
			i++
		}
	}

	return result
}

// fuseArithmeticInstructions combines arithmetic operations where possible
func (bo *BytecodeOptimizer) fuseArithmeticInstructions(instructions []byte) []byte {
	if len(instructions) < 2 {
		return instructions
	}

	result := make([]byte, 0, len(instructions))
	i := 0

	for i < len(instructions) {
		current := vm.Opcode(instructions[i])

		// Look for patterns like: Push constant, Push constant, Add
		// These could be optimized to: Push (constant1 + constant2)
		if current == vm.OpConstant && i+6 < len(instructions) {
			// Check if next instruction is also OpConstant
			if vm.Opcode(instructions[i+3]) == vm.OpConstant && i+6 < len(instructions) {
				// Check if followed by an arithmetic operation
				nextOp := vm.Opcode(instructions[i+6])
				if bo.isArithmeticOp(nextOp) {
					// For now, just copy as-is to avoid complexity
					result = append(result, instructions[i:i+3]...)
					i += 3
					continue
				}
			}
		}

		// Copy current instruction
		if current == vm.OpConstant && i+2 < len(instructions) {
			result = append(result, instructions[i:i+3]...)
			i += 3
		} else {
			result = append(result, instructions[i])
			i++
		}
	}

	return result
}

// optimizeConstantSequences optimizes sequences of constant operations
func (bo *BytecodeOptimizer) optimizeConstantSequences(instructions []byte) []byte {
	// This is a placeholder for more advanced constant propagation
	// In a full implementation, this would track constant values through
	// the instruction stream and pre-compute results
	return instructions
}

// isArithmeticOp checks if an opcode is an arithmetic operation
func (bo *BytecodeOptimizer) isArithmeticOp(op vm.Opcode) bool {
	switch op {
	case vm.OpAdd, vm.OpSub, vm.OpMul, vm.OpDiv, vm.OpMod:
		return true
	case vm.OpAddInt64, vm.OpSubInt64, vm.OpMulInt64, vm.OpDivInt64, vm.OpModInt64:
		return true
	case vm.OpAddFloat64, vm.OpSubFloat64, vm.OpMulFloat64, vm.OpDivFloat64, vm.OpModFloat64:
		return true
	case vm.OpAddString:
		return true
	default:
		return false
	}
}

// AnalyzeStackDepth analyzes the maximum stack depth required
func (bo *BytecodeOptimizer) AnalyzeStackDepth(instructions []byte) int {
	maxDepth := 0
	currentDepth := 0
	i := 0

	for i < len(instructions) {
		current := vm.Opcode(instructions[i])

		switch current {
		case vm.OpConstant:
			currentDepth++
			i += 3 // Skip operand bytes
		case vm.OpGetVar:
			currentDepth++
			i += 3 // Skip operand bytes
		case vm.OpPop:
			if currentDepth > 0 {
				currentDepth--
			}
			i++
		case vm.OpAdd, vm.OpSub, vm.OpMul, vm.OpDiv, vm.OpMod:
			if currentDepth >= 2 {
				currentDepth-- // Two operands become one result
			}
			i++
		case vm.OpAddInt64, vm.OpSubInt64, vm.OpMulInt64, vm.OpDivInt64, vm.OpModInt64:
			if currentDepth >= 2 {
				currentDepth--
			}
			i++
		case vm.OpAddFloat64, vm.OpSubFloat64, vm.OpMulFloat64, vm.OpDivFloat64, vm.OpModFloat64:
			if currentDepth >= 2 {
				currentDepth--
			}
			i++
		case vm.OpAddString:
			if currentDepth >= 2 {
				currentDepth--
			}
			i++
		default:
			i++
		}

		if currentDepth > maxDepth {
			maxDepth = currentDepth
		}
	}

	return maxDepth + 10 // Add buffer for safety
}
