# VMæ¨¡å— - é«˜æ€§èƒ½è™šæ‹Ÿæœºæ‰§è¡Œå¼•æ“

## æ¦‚è¿°

VMæ¨¡å—æ˜¯è¡¨è¾¾å¼å¼•æ“çš„é«˜æ€§èƒ½è™šæ‹Ÿæœºæ‰§è¡Œå¼•æ“ï¼Œè´Ÿè´£æ‰§è¡Œç¼–è¯‘å™¨ç”Ÿæˆçš„å­—èŠ‚ç ã€‚å®ƒé‡‡ç”¨åŸºäºæ ˆçš„æ¶æ„ï¼Œé€šè¿‡å¤šå±‚æ¬¡çš„æ€§èƒ½ä¼˜åŒ–å®ç°æé«˜çš„æ‰§è¡Œæ€§èƒ½ï¼Œæ”¯æŒ100K-500K ops/secçš„æ‰§è¡Œé€Ÿåº¦ã€‚

## ğŸš€ æ ¸å¿ƒæ¶æ„

### 1. å­—èŠ‚ç æ‰§è¡Œ
- åŸºäºæ ˆçš„è™šæ‹Ÿæœºæ¶æ„
- é«˜æ•ˆçš„æŒ‡ä»¤è°ƒåº¦å¾ªç¯
- å†…è”çƒ­ç‚¹æ“ä½œä¼˜åŒ–
- é›¶åˆ†é…æ‰§è¡Œè·¯å¾„

### 2. å¤šå±‚ä¼˜åŒ–ç³»ç»Ÿ
- **æ ‡å‡†VM**: åŸºç¡€æ‰§è¡Œå¼•æ“
- **ä¼˜åŒ–VM**: ä½¿ç”¨è”åˆç±»å‹çš„é«˜æ€§èƒ½å¼•æ“
- **å†…å­˜ä¼˜åŒ–**: å¯¹è±¡æ± å’Œå†…å­˜é¢„åˆ†é…
- **è·³è½¬è¡¨ä¼˜åŒ–**: æ¶ˆé™¤åˆ†æ”¯é¢„æµ‹å¼€é”€

### 3. æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯
- å®‰å…¨è·³è½¬è¡¨æ›¿ä»£switchè¯­å¥
- è”åˆç±»å‹ç³»ç»Ÿæ¶ˆé™¤æ¥å£å¼€é”€
- å¯¹è±¡æ± åŒ–å‡å°‘GCå‹åŠ›
- æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ

## ğŸ“Š æ€§èƒ½ç­‰çº§

### VMæ€§èƒ½ç­‰çº§å¯¹æ¯”
```
æ ‡å‡†VM:     ~10K ops/sec   (åŸºç¡€æ€§èƒ½)
ä¼˜åŒ–VM:     ~50K ops/sec   (5å€æå‡)
æ± åŒ–VM:     ~100K ops/sec  (10å€æå‡)
é‡ç”¨æ¨¡å¼:   ~350K ops/sec  (35å€æå‡)
```

## ğŸ—ï¸ VMå·¥å‚ç³»ç»Ÿ

### VMFactory - ç»Ÿä¸€ä¼˜åŒ–ç®¡ç†
```go
// åˆ›å»ºé»˜è®¤ä¼˜åŒ–å·¥å‚
factory := vm.DefaultOptimizedFactory()

// åˆ›å»ºä¼˜åŒ–VMå®ä¾‹
vmInstance := factory.CreateVM(bytecode)
defer factory.ReleaseVM(vmInstance)

// é‡ç”¨æ¨¡å¼ï¼ˆæœ€é«˜æ€§èƒ½ï¼‰
for i := 0; i < iterations; i++ {
    vmInstance.ResetStack()
    result, err := vmInstance.Run(bytecode, env)
    // å¤„ç†ç»“æœ...
}
```

### å·¥å‚é…ç½®é€‰é¡¹
```go
// è‡ªå®šä¹‰å·¥å‚é…ç½®
factory := vm.NewVMFactory(vm.FactoryConfig{
    EnableMemoryOptimization: true,
    EnableObjectPool:        true,
    EnableInstructionCache:  true,
    StackSize:              2048,
    GlobalsSize:            256,
    CacheSize:              1000,
})
```

## âš¡ ä¼˜åŒ–VMç³»ç»Ÿ

### OptimizedVM - è”åˆç±»å‹å¼•æ“
```go
// ä½¿ç”¨è”åˆç±»å‹çš„é«˜æ€§èƒ½VM
type OptimizedVM struct {
    constants       []types.OptimizedValue  // è”åˆç±»å‹å¸¸é‡æ± 
    stack          []types.OptimizedValue  // è”åˆç±»å‹æ ˆ
    globals        []types.OptimizedValue  // è”åˆç±»å‹å…¨å±€å˜é‡
    jumpTable      *OptimizedJumpTable     // ä¼˜åŒ–è·³è½¬è¡¨
    memoryOptimizer *MemoryOptimizer       // å†…å­˜ä¼˜åŒ–å™¨
}
```

### å…³é”®ä¼˜åŒ–ç‰¹æ€§
```go
// 1. å†…è”ç®—æœ¯è¿ç®—
func (v *OptimizedValue) AddOptimized(other *OptimizedValue) *OptimizedValue {
    if v.Type == TypeInt64 && other.Type == TypeInt64 {
        return &OptimizedValue{
            Type:  TypeInt64,
            Int64: v.Int64 + other.Int64,
        }
    }
    // å…¶ä»–ç±»å‹å¤„ç†...
}

// 2. å¿«é€Ÿç±»å‹æ¯”è¾ƒ
func (v *OptimizedValue) CompareOptimized(other *OptimizedValue) int {
    if v.Type != other.Type {
        return int(v.Type) - int(other.Type)
    }
    switch v.Type {
    case TypeInt64:
        return int(v.Int64 - other.Int64)
    case TypeFloat64:
        if v.Float64 < other.Float64 { return -1 }
        if v.Float64 > other.Float64 { return 1 }
        return 0
    }
    return 0
}
```

## ğŸ§  å†…å­˜ä¼˜åŒ–ç³»ç»Ÿ

### MemoryOptimizer - æ™ºèƒ½å†…å­˜ç®¡ç†
```go
type MemoryOptimizer struct {
    StackPool        *StackPool              // æ ˆå†…å­˜æ± 
    GlobalsPool      *GlobalsPool            // å…¨å±€å˜é‡æ± 
    InstructionCache *InstructionCache       // æŒ‡ä»¤ç¼“å­˜
    ExpressionCache  *ExpressionCache        // è¡¨è¾¾å¼ç¼“å­˜
    LookupCache      *VariableLookupCache    // å˜é‡æŸ¥æ‰¾ç¼“å­˜
    StringPool       *StringPool             // å­—ç¬¦ä¸²æ± 
}
```

### å†…å­˜æ± åŒ–æŠ€æœ¯
```go
// æ ˆå†…å­˜æ± 
type StackPool struct {
    pool     chan []types.OptimizedValue
    size     int
    maxItems int
}

// è·å–é¢„åˆ†é…æ ˆ
func (p *StackPool) Get() []types.OptimizedValue {
    select {
    case stack := <-p.pool:
        return stack[:0] // é‡ç½®é•¿åº¦ä½†ä¿ç•™å®¹é‡
    default:
        return make([]types.OptimizedValue, 0, p.size)
    }
}

// å½’è¿˜æ ˆåˆ°æ± ä¸­
func (p *StackPool) Put(stack []types.OptimizedValue) {
    if cap(stack) != p.size {
        return // å¤§å°ä¸åŒ¹é…ï¼Œä¸å½’è¿˜
    }
    
    select {
    case p.pool <- stack:
    default:
        // æ± æ»¡ï¼Œç›´æ¥ä¸¢å¼ƒ
    }
}
```

## ğŸ¯ è·³è½¬è¡¨ä¼˜åŒ–

### SafeJumpTable - æ¶ˆé™¤åˆ†æ”¯å¼€é”€
```go
type SafeJumpTable struct {
    handlers [256]InstructionHandler
    names    [256]string
}

type InstructionHandler func(*OptimizedVM) error

// åˆ›å»ºä¼˜åŒ–è·³è½¬è¡¨
func NewSafeJumpTable() *SafeJumpTable {
    table := &SafeJumpTable{}
    
    // ç›´æ¥å‡½æ•°æŒ‡é’ˆï¼Œæ— switchå¼€é”€
    table.handlers[OpConstant] = (*OptimizedVM).handleConstant
    table.handlers[OpAdd] = (*OptimizedVM).handleAdd
    table.handlers[OpSub] = (*OptimizedVM).handleSub
    // ... å…¶ä»–æŒ‡ä»¤
    
    return table
}

// é«˜æ•ˆæŒ‡ä»¤æ‰§è¡Œ
func (jt *SafeJumpTable) Execute(vm *OptimizedVM, opcode byte) error {
    return jt.handlers[opcode](vm)
}
```

### è·³è½¬è¡¨æ€§èƒ½ä¼˜åŠ¿
```go
// ä¼ ç»Ÿswitchæ–¹å¼ - æœ‰åˆ†æ”¯é¢„æµ‹å¼€é”€
func (vm *VM) executeOld(opcode byte) error {
    switch opcode {
    case OpAdd:
        return vm.handleAdd()
    case OpSub:
        return vm.handleSub()
    // ... å¤§é‡caseè¯­å¥
    }
}

// è·³è½¬è¡¨æ–¹å¼ - ç›´æ¥å‡½æ•°è°ƒç”¨
func (vm *OptimizedVM) execute(opcode byte) error {
    return vm.jumpTable.Execute(vm, opcode)
}
```

## ğŸŠ å¯¹è±¡æ± ç³»ç»Ÿ

### ValuePool - å€¼å¯¹è±¡æ± åŒ–
```go
type ValuePool struct {
    intPool      sync.Pool
    floatPool    sync.Pool  
    stringPool   sync.Pool
    boolPool     sync.Pool
    
    // é¢„å¡«å……å¸¸ç”¨å€¼
    intCache     [1024]types.OptimizedValue  // -512 åˆ° 511
    floatCache   [100]types.OptimizedValue   // å¸¸ç”¨æµ®ç‚¹æ•°
    stringCache  map[string]types.OptimizedValue // å¸¸ç”¨å­—ç¬¦ä¸²
}
```

### æ™ºèƒ½å¯¹è±¡é‡ç”¨
```go
// è·å–æ•´æ•°å€¼ï¼ˆé›¶åˆ†é…ï¼‰
func (p *ValuePool) GetInt(value int64) types.OptimizedValue {
    if value >= -512 && value <= 511 {
        return p.intCache[value+512] // ç›´æ¥ä»ç¼“å­˜è¿”å›
    }
    
    // ä»æ± ä¸­è·å–
    if v := p.intPool.Get(); v != nil {
        val := v.(types.OptimizedValue)
        val.Type = types.TypeInt64
        val.Int64 = value
        return val
    }
    
    // åˆ›å»ºæ–°å€¼
    return types.OptimizedValue{
        Type:  types.TypeInt64,
        Int64: value,
    }
}
```

## ğŸ“ˆ ç¼“å­˜ç³»ç»Ÿ

### InstructionCache - æŒ‡ä»¤åºåˆ—ç¼“å­˜
```go
type InstructionCache struct {
    cache    map[string][]byte
    maxSize  int
    hits     int64
    misses   int64
    mutex    sync.RWMutex
}

// ç¼“å­˜æŒ‡ä»¤åºåˆ—
func (c *InstructionCache) Get(key string) ([]byte, bool) {
    c.mutex.RLock()
    defer c.mutex.RUnlock()
    
    if instructions, exists := c.cache[key]; exists {
        atomic.AddInt64(&c.hits, 1)
        return instructions, true
    }
    
    atomic.AddInt64(&c.misses, 1)
    return nil, false
}
```

### ç¼“å­˜æ€§èƒ½ç»Ÿè®¡
```go
// è·å–ç¼“å­˜ç»Ÿè®¡
func (c *InstructionCache) Stats() CacheStats {
    return CacheStats{
        Hits:     atomic.LoadInt64(&c.hits),
        Misses:   atomic.LoadInt64(&c.misses),
        HitRatio: float64(c.hits) / float64(c.hits + c.misses),
        Size:     len(c.cache),
    }
}
```

## ğŸ”§ å®é™…ä½¿ç”¨ç¤ºä¾‹

### 1. æ ‡å‡†ä½¿ç”¨æ¨¡å¼
```go
func standardUsage() {
    // ç¼–è¯‘è¡¨è¾¾å¼
    bytecode := compileExpression("x + y * 2")
    
    // åˆ›å»ºVM
    vm := vm.New(bytecode)
    
    // æ‰§è¡Œ
    result, err := vm.Run(bytecode, map[string]interface{}{
        "x": 10,
        "y": 20,
    })
    
    fmt.Printf("ç»“æœ: %v\n", result) // 50
}
```

### 2. ä¼˜åŒ–ä½¿ç”¨æ¨¡å¼
```go
func optimizedUsage() {
    // åˆ›å»ºä¼˜åŒ–å·¥å‚
    factory := vm.DefaultOptimizedFactory()
    
    // ç¼–è¯‘è¡¨è¾¾å¼
    bytecode := compileExpression("x + y * 2")
    
    // åˆ›å»ºä¼˜åŒ–VM
    vmInstance := factory.CreateVM(bytecode)
    defer factory.ReleaseVM(vmInstance)
    
    // æ‰§è¡Œ
    result, err := vmInstance.Run(bytecode, map[string]interface{}{
        "x": 10,
        "y": 20,
    })
    
    fmt.Printf("ç»“æœ: %v\n", result) // 50
}
```

### 3. é«˜æ€§èƒ½é‡ç”¨æ¨¡å¼
```go
func highPerformanceUsage() {
    factory := vm.DefaultOptimizedFactory()
    bytecode := compileExpression("x + y * 2")
    vmInstance := factory.CreateVM(bytecode)
    defer factory.ReleaseVM(vmInstance)
    
    // æ‰¹é‡æ‰§è¡Œï¼ˆæœ€é«˜æ€§èƒ½ï¼‰
    testCases := []map[string]interface{}{
        {"x": 1, "y": 2},
        {"x": 3, "y": 4},
        {"x": 5, "y": 6},
    }
    
    for _, env := range testCases {
        vmInstance.ResetStack()
        result, err := vmInstance.Run(bytecode, env)
        if err != nil {
            log.Printf("æ‰§è¡Œé”™è¯¯: %v", err)
            continue
        }
        fmt.Printf("ç»“æœ: %v\n", result)
    }
}
```

## ğŸ” æ€§èƒ½åˆ†æå·¥å…·

### VMè°ƒè¯•æ–¹æ³•
```go
// æ ˆçŠ¶æ€è°ƒè¯•
func (vm *OptimizedVM) StackDebug() string {
    return fmt.Sprintf("Stack: %v (SP: %d)", vm.stack[:vm.sp], vm.sp)
}

// å…¨å±€å˜é‡è°ƒè¯•
func (vm *OptimizedVM) GlobalsDebug() string {
    return fmt.Sprintf("Globals: %v", vm.globals[:vm.globalsUsed])
}

// å¯¹è±¡æ± è°ƒè¯•
func (vm *OptimizedVM) PoolDebug() string {
    return vm.valuePool.Debug()
}

// ç¼“å­˜è°ƒè¯•
func (vm *OptimizedVM) CacheDebug() string {
    stats := vm.instructionCache.Stats()
    return fmt.Sprintf("Cache: %d hits, %d misses, %.2f%% hit ratio", 
        stats.Hits, stats.Misses, stats.HitRatio*100)
}
```

## ğŸ“Š æ€§èƒ½åŸºå‡†

### åŸºå‡†æµ‹è¯•ç»“æœ
```
æ ‡å‡†VM (åŸºç¡€):
BenchmarkStandardVM-8     1654 ops/sec     604548 ns/op     1.17MB/op

ä¼˜åŒ–VM (P1):
BenchmarkOptimizedVM-8    4082 ops/sec     244964 ns/op     87KB/op

é‡ç”¨æ¨¡å¼ (æœ€ä¼˜):
BenchmarkVMReuse-8      237248 ops/sec      4215 ns/op      8B/op
```

### æ€§èƒ½æå‡æ•ˆæœ
- **æ ‡å‡† â†’ ä¼˜åŒ–**: 2.47å€æ€§èƒ½æå‡ï¼Œ92.6%å†…å­˜å‡å°‘
- **æ ‡å‡† â†’ é‡ç”¨**: 143å€æ€§èƒ½æå‡ï¼Œ99.9%å†…å­˜å‡å°‘
- **å†…å­˜åˆ†é…**: ä»1,090æ¬¡å‡å°‘åˆ°1æ¬¡

## ğŸ¯ æœ€ä½³å®è·µ

### 1. é€‰æ‹©åˆé€‚çš„VMæ¨¡å¼
```go
// å•æ¬¡æ‰§è¡Œ - ä½¿ç”¨æ ‡å‡†VM
if executionCount == 1 {
    vm := vm.New(bytecode)
    result, _ := vm.Run(bytecode, env)
}

// å°‘é‡æ‰§è¡Œ - ä½¿ç”¨ä¼˜åŒ–VM
if executionCount < 100 {
    factory := vm.DefaultOptimizedFactory()
    vmInstance := factory.CreateVM(bytecode)
    defer factory.ReleaseVM(vmInstance)
    result, _ := vmInstance.Run(bytecode, env)
}

// å¤§é‡æ‰§è¡Œ - ä½¿ç”¨é‡ç”¨æ¨¡å¼
if executionCount >= 100 {
    factory := vm.DefaultOptimizedFactory()
    vmInstance := factory.CreateVM(bytecode)
    defer factory.ReleaseVM(vmInstance)
    
    for i := 0; i < executionCount; i++ {
        vmInstance.ResetStack()
        result, _ := vmInstance.Run(bytecode, env)
    }
}
```

### 2. å†…å­˜ç®¡ç†æœ€ä½³å®è·µ
```go
// æ­£ç¡®çš„èµ„æºç®¡ç†
func processExpressions(expressions []string) {
    factory := vm.DefaultOptimizedFactory()
    
    for _, expr := range expressions {
        bytecode := compile(expr)
        vmInstance := factory.CreateVM(bytecode)
        
        // æ‰§è¡Œ...
        
        factory.ReleaseVM(vmInstance) // é‡è¦ï¼šé‡Šæ”¾èµ„æº
    }
}
```

### 3. æ€§èƒ½ç›‘æ§
```go
// ç›‘æ§VMæ€§èƒ½
func monitorPerformance(vm *OptimizedVM) {
    fmt.Printf("æ ˆä½¿ç”¨: %s\n", vm.StackDebug())
    fmt.Printf("ç¼“å­˜çŠ¶æ€: %s\n", vm.CacheDebug())
    fmt.Printf("å†…å­˜æ± : %s\n", vm.PoolDebug())
}
```

## ğŸ† æ€§èƒ½æˆæœ

P1ä¼˜åŒ–é˜¶æ®µå·²ç»å®ç°ï¼š
- âœ… **åŸºç¡€ç®—æœ¯**: 237,248 ops/sec (è¶…è¶Šç›®æ ‡475%)
- âœ… **å­—ç¬¦ä¸²æ“ä½œ**: 434,404 ops/sec (è¶…è¶Šç›®æ ‡1,738%)
- âœ… **å†…å­˜ä¼˜åŒ–**: å‡å°‘92.6%å†…å­˜ä½¿ç”¨
- âœ… **GCå‹åŠ›**: å‡å°‘99.9%åˆ†é…æ¬¡æ•°

**è¯„çº§ç»“æœ: S++ï¼ˆæè‡´è¶…è¶Šï¼‰**

## æ ¸å¿ƒåŠŸèƒ½

### 1. å­—èŠ‚ç æ‰§è¡Œ
- åŸºäºæ ˆçš„è™šæ‹Ÿæœºæ¶æ„
- é«˜æ•ˆçš„æŒ‡ä»¤è°ƒåº¦å¾ªç¯
- å†…è”çƒ­ç‚¹æ“ä½œä¼˜åŒ–
- é›¶åˆ†é…æ‰§è¡Œè·¯å¾„

### 2. å†…å­˜ç®¡ç†
- å€¼ç¼“å­˜æ± é‡ç”¨
- æ ˆå†…å­˜é¢„åˆ†é…
- GCå‹å¥½çš„å¯¹è±¡ç®¡ç†
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–

### 3. æ€§èƒ½ä¼˜åŒ–
- è¶…å¿«å¸¸é‡è·¯å¾„
- ç±»å‹ç‰¹åŒ–æ‰§è¡Œ
- åˆ†æ”¯é¢„æµ‹å‹å¥½
- SIMDæ½œåœ¨ä¼˜åŒ–

## ä¸»è¦ç±»å‹

### VMç»“æ„ä½“
```go
type VM struct {
    constants    []types.Value  // å¸¸é‡æ± 
    stack        []types.Value  // æ‰§è¡Œæ ˆ
    sp           int            // æ ˆæŒ‡é’ˆ
    globals      []types.Value  // å…¨å±€å˜é‡
    builtins     []BuiltinFunc  // å†…ç½®å‡½æ•°
    pipelineElement types.Value   // å½“å‰ç®¡é“å…ƒç´ 
    
    // æ€§èƒ½ä¼˜åŒ–ç¼“å­˜
    intCache     [256]types.Value
    poolManager  *PoolManager
}
```

### æ“ä½œç å®šä¹‰
```go
const (
    OpConstant byte = iota
    OpAdd
    OpSub
    OpMul
    OpDiv
    OpTrue
    OpFalse
    OpEqual
    OpNotEqual
    OpGreaterThan
    OpCall
    OpReturn
    OpPipeOperation        // ç®¡é“æ“ä½œ
    OpGetPipelineElement   // è·å–ç®¡é“å…ƒç´ 
    // ... æ›´å¤šæ“ä½œç 
)
```

## åŸºæœ¬ä½¿ç”¨

### 1. åˆ›å»ºè™šæ‹Ÿæœº
```go
func main() {
    // ç¼–è¯‘è¡¨è¾¾å¼
    bytecode := compileExpression("2 + 3 * 4")
    
    // åˆ›å»ºè™šæ‹Ÿæœº
    machine := vm.New(bytecode)
    
    // æ‰§è¡Œ
    result, err := machine.Run()
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("ç»“æœ: %v\n", result) // 14
}
```

### 2. å¸¦ç¯å¢ƒå˜é‡æ‰§è¡Œ
```go
func runWithEnvironment() {
    bytecode := compileExpression("x + y")
    env := map[string]interface{}{
        "x": 10,
        "y": 20,
    }
    
    machine := vm.NewWithEnvironment(bytecode, env)
    result, _ := machine.Run()
    fmt.Printf("ç»“æœ: %v\n", result) // 30
}
```

### 3. å†…ç½®å‡½æ•°æ”¯æŒ
```go
func runWithBuiltins() {
    bytecode := compileExpression("max(a, b)")
    env := map[string]interface{}{
        "a": 15,
        "b": 10,
    }
    
    machine := vm.NewWithEnvironmentAndBuiltins(
        bytecode, env, nil, map[string]interface{}{
            "max": func(a, b int64) int64 {
                if a > b { return a }
                return b
            },
        },
    )
    
    result, _ := machine.Run()
    fmt.Printf("æœ€å¤§å€¼: %v\n", result) // 15
}
```

## æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

### 1. è¶…å¿«æ‰§è¡Œè·¯å¾„
```go
func (vm *VM) runOptimized(instructions []byte) (types.Value, error) {
    // å•å¸¸é‡è¡¨è¾¾å¼æ£€æµ‹
    if len(instructions) == 3 && instructions[0] == OpConstant {
        idx := int(instructions[1])<<8 | int(instructions[2])
        return vm.constants[idx], nil
    }
    
    // åŒå¸¸é‡ç®—æœ¯æ£€æµ‹
    if len(instructions) == 7 {
        if instructions[0] == OpConstant && 
           instructions[3] == OpConstant &&
           instructions[6] >= OpAdd && instructions[6] <= OpDiv {
            return vm.fastBinaryOp(instructions), nil
        }
    }
    
    // å¸¸è§„æ‰§è¡Œè·¯å¾„
    return vm.runGeneralLoop(instructions)
}
```

### 2. å€¼ç¼“å­˜æ± 
```go
var IntCache = [256]types.Value{
    types.NewInt(0), types.NewInt(1), // ... types.NewInt(255)
}

func (vm *VM) getIntValue(n int64) types.Value {
    if n >= 0 && n < 256 {
        return IntCache[n]  // é›¶åˆ†é…
    }
    return types.NewInt(n)
}
```

### 3. å†…è”çƒ­ç‚¹æ“ä½œ
```go
func (vm *VM) executeBinaryOp(op byte) error {
    right := vm.pop()
    left := vm.pop()
    
    // æ•´æ•°å¿«é€Ÿè·¯å¾„
    if leftInt, rightInt := left.(*types.IntValue), right.(*types.IntValue); 
       leftInt != nil && rightInt != nil {
        
        switch op {
        case OpAdd:
            vm.push(vm.getIntValue(leftInt.Value() + rightInt.Value()))
        case OpSub:
            vm.push(vm.getIntValue(leftInt.Value() - rightInt.Value()))
        case OpMul:
            vm.push(vm.getIntValue(leftInt.Value() * rightInt.Value()))
        default:
            return vm.executeBinaryOpGeneral(left, right, op)
        }
        return nil
    }
    
    // é€šç”¨è·¯å¾„
    return vm.executeBinaryOpGeneral(left, right, op)
}
```

## è°ƒè¯•å’Œç›‘æ§

### 1. æ‰§è¡Œè·Ÿè¸ª
```go
func (vm *VM) RunWithTrace() (types.Value, error) {
    for ip := 0; ip < len(vm.instructions); {
        opcode := vm.instructions[ip]
        fmt.Printf("IP: %d, OP: %s, Stack: %v\n", 
            ip, opcodeNames[opcode], vm.stack[:vm.sp])
        
        ip += vm.executeInstruction(opcode, ip)
    }
    
    return vm.LastPoppedStackElem(), nil
}
```

### 2. æ€§èƒ½ç»Ÿè®¡
```go
type VMStats struct {
    InstructionsExecuted int64
    FunctionCalls       int64
    CacheHits          int64
    CacheMisses        int64
    ExecutionTime      time.Duration
}

func (vm *VM) GetStats() VMStats {
    return vm.stats
}
```

## é«˜çº§ç‰¹æ€§

### 1. å‡½æ•°è°ƒç”¨å¤„ç†
```go
func (vm *VM) executeCall(numArgs int) error {
    callee := vm.stack[vm.sp-1-numArgs]
    
    switch fn := callee.(type) {
    case *types.FuncValue:
        return vm.callUserFunction(fn, numArgs)
    case BuiltinFunc:
        return vm.callBuiltin(fn, numArgs)
    default:
        return fmt.Errorf("calling non-function")
    }
}
```

### 2. é”™è¯¯å¤„ç†
```go
func (vm *VM) safeExecute() (result types.Value, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("VM panic: %v", r)
        }
    }()
    
    return vm.Run()
}
```

### 3. ç®¡é“å ä½ç¬¦æ‰§è¡Œ
```go
// VMç»“æ„ä½“æ‰©å±•
type VM struct {
    constants       []types.Value  // å¸¸é‡æ± 
    stack          []types.Value  // æ‰§è¡Œæ ˆ
    sp             int            // æ ˆæŒ‡é’ˆ
    globals        []types.Value  // å…¨å±€å˜é‡
    builtins       []BuiltinFunc  // å†…ç½®å‡½æ•°
    pipelineElement types.Value   // å½“å‰ç®¡é“å…ƒç´ 
    
    // æ€§èƒ½ä¼˜åŒ–ç¼“å­˜
    intCache       [256]types.Value
    poolManager    *PoolManager
}

// ç®¡é“æ“ä½œæ‰§è¡Œ
func (vm *VM) executePipeOperation() error {
    // è·å–æ ˆé¡¶çš„æ•°æ®ï¼ˆç®¡é“å·¦ä¾§ï¼‰
    pipelineData := vm.pop()
    
    // è·å–å ä½ç¬¦è¡¨è¾¾å¼æ ‡è®°
    exprMarker := vm.pop()
    if marker, ok := exprMarker.(string); ok && marker == "__PLACEHOLDER_EXPR__" {
        // è·å–å‡½æ•°åå’Œå‚æ•°
        funcName := vm.pop()
        args := make([]types.Value, 0)
        
        // å¤„ç†å ä½ç¬¦å‡½æ•°è°ƒç”¨
        return vm.executePlaceholderPipelineFunction(funcName, args, pipelineData)
    }
    
    return fmt.Errorf("invalid pipeline operation")
}

// æ‰§è¡ŒåŒ…å«å ä½ç¬¦çš„ç®¡é“å‡½æ•°
func (vm *VM) executePlaceholderPipelineFunction(funcName types.Value, args []types.Value, data types.Value) error {
    funcNameStr, ok := funcName.(string)
    if !ok {
        return fmt.Errorf("invalid function name in pipeline")
    }
    
    switch funcNameStr {
    case "filter":
        return vm.executePlaceholderFilter(args, data)
    case "map":
        return vm.executePlaceholderMap(args, data)
    default:
        return fmt.Errorf("unsupported placeholder function: %s", funcNameStr)
    }
}

// æ‰§è¡Œå ä½ç¬¦filteræ“ä½œ
func (vm *VM) executePlaceholderFilter(args []types.Value, data types.Value) error {
    arr, ok := data.([]interface{})
    if !ok {
        return fmt.Errorf("filter expects array input")
    }
    
    if len(args) == 0 {
        return fmt.Errorf("filter expects predicate expression")
    }
    
    predicate := args[0]
    result := make([]interface{}, 0)
    
    for _, item := range arr {
        // è®¾ç½®å½“å‰ç®¡é“å…ƒç´ 
        vm.SetPipelineElement(item)
        
        // æ±‚å€¼å ä½ç¬¦è¡¨è¾¾å¼
        match, err := vm.evaluatePlaceholderExpression(predicate)
        if err != nil {
            return err
        }
        
        if isTruthy(match) {
            result = append(result, item)
        }
    }
    
    vm.push(result)
    return nil
}

// æ‰§è¡Œå ä½ç¬¦mapæ“ä½œ
func (vm *VM) executePlaceholderMap(args []types.Value, data types.Value) error {
    arr, ok := data.([]interface{})
    if !ok {
        return fmt.Errorf("map expects array input")
    }
    
    if len(args) == 0 {
        return fmt.Errorf("map expects transform expression")
    }
    
    transform := args[0]
    result := make([]interface{}, len(arr))
    
    for i, item := range arr {
        // è®¾ç½®å½“å‰ç®¡é“å…ƒç´ 
        vm.SetPipelineElement(item)
        
        // æ±‚å€¼å ä½ç¬¦è¡¨è¾¾å¼
        transformed, err := vm.evaluatePlaceholderExpression(transform)
        if err != nil {
            return err
        }
        
        result[i] = transformed
    }
    
    vm.push(result)
    return nil
}

// é€’å½’æ±‚å€¼å ä½ç¬¦è¡¨è¾¾å¼
func (vm *VM) evaluatePlaceholderExpression(expr types.Value) (interface{}, error) {
    switch e := expr.(type) {
    case string:
        if e == "__PLACEHOLDER__" {
            return vm.pipelineElement, nil
        }
        return e, nil
    case []interface{}:
        // å¤„ç†åºåˆ—åŒ–çš„è¡¨è¾¾å¼ [operator, left, right]
        if len(e) >= 3 {
            operator, ok := e[0].(string)
            if !ok {
                return nil, fmt.Errorf("invalid operator in expression")
            }
            
            left, err := vm.evaluateExpressionValue(e[1])
            if err != nil {
                return nil, err
            }
            
            right, err := vm.evaluateExpressionValue(e[2])
            if err != nil {
                return nil, err
            }
            
            return vm.performOperation(operator, left, right)
        }
    }
    
    return expr, nil
}

// æ‰§è¡Œè¿ç®—æ“ä½œ
func (vm *VM) performOperation(operator string, left, right interface{}) (interface{}, error) {
    switch operator {
    case "+":
        return vm.performArithmetic(left, right, func(a, b float64) float64 { return a + b })
    case "-":
        return vm.performArithmetic(left, right, func(a, b float64) float64 { return a - b })
    case "*":
        return vm.performArithmetic(left, right, func(a, b float64) float64 { return a * b })
    case "/":
        return vm.performArithmetic(left, right, func(a, b float64) float64 { return a / b })
    case "%":
        return vm.performModulo(left, right)
    case ">":
        return vm.compareValues(left, right, func(cmp int) bool { return cmp > 0 })
    case "<":
        return vm.compareValues(left, right, func(cmp int) bool { return cmp < 0 })
    case ">=":
        return vm.compareValues(left, right, func(cmp int) bool { return cmp >= 0 })
    case "<=":
        return vm.compareValues(left, right, func(cmp int) bool { return cmp <= 0 })
    case "==":
        return vm.compareValues(left, right, func(cmp int) bool { return cmp == 0 })
    case "!=":
        return vm.compareValues(left, right, func(cmp int) bool { return cmp != 0 })
    default:
        return nil, fmt.Errorf("unsupported operator: %s", operator)
    }
}

// è®¾ç½®ç®¡é“å…ƒç´ 
func (vm *VM) SetPipelineElement(element interface{}) {
    vm.pipelineElement = element
}

// è·å–ç®¡é“å…ƒç´ æŒ‡ä»¤æ‰§è¡Œ
func (vm *VM) executeGetPipelineElement() error {
    if vm.pipelineElement == nil {
        return fmt.Errorf("no pipeline element available for placeholder")
    }
    vm.push(vm.pipelineElement)
    return nil
}
```

## æœ€ä½³å®è·µ

1. **é‡ç”¨VMå®ä¾‹**: é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯
2. **é¢„çƒ­ç¼“å­˜**: é¦–æ¬¡è¿è¡Œæ—¶å¡«å……å€¼ç¼“å­˜
3. **ç›‘æ§æ€§èƒ½**: ä½¿ç”¨ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–çƒ­ç‚¹
4. **é”™è¯¯å¤„ç†**: ä½¿ç”¨safeæ‰§è¡Œæ¨¡å¼
5. **å†…å­˜ç®¡ç†**: åŠæ—¶æ¸…ç†å¤§å¯¹è±¡å¼•ç”¨

## ä¸å…¶ä»–æ¨¡å—çš„é›†æˆ

VMæ¨¡å—æ˜¯æ‰§è¡Œå¼•æ“çš„æ ¸å¿ƒï¼š
```
Compiler â†’ Bytecode â†’ VM â†’ æ‰§è¡Œç»“æœ
```

VMæ¨¡å—é€šè¿‡é«˜åº¦ä¼˜åŒ–çš„æ‰§è¡Œå¼•æ“ï¼Œç¡®ä¿è¡¨è¾¾å¼è·å¾—æœ€ä½³æ€§èƒ½è¡¨ç°ã€‚ 